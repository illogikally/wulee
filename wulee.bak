#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>

#pragma pack(1)
typedef struct {
    uint16_t bfType;
    uint32_t bfSize;
    uint16_t bfReserved1;
    uint16_t bfReserved2;
    uint32_t bfOffBits;

    uint32_t biSize;
    uint32_t biWidth;
    uint32_t biHeight;
    uint16_t biPlanes;
    uint16_t biBitCount;
    uint32_t biCompression;
    uint32_t biSizeImage;
    uint32_t biXPelsPerMeter;
    uint32_t biYPelsPerMeter;
    uint32_t biClrUsed;
    uint32_t biClrImportant;
  
    uint64_t ClrPallete;
} BITMAPHEADER;

BITMAPHEADER imgHeader; 
int bWidth, bHeight; //Stego block size
int imgWidth;
int imgHeight;
int rowSize;
int imgDataSize;
int imgDataWidth;
uint8_t mSize; //Binary message size in bit

uint8_t* readImg(char *imgPath) {
	FILE *img = fopen(imgPath, "rb");
	if(img == NULL) {
		printf("Can't open the image, make sure the path is correct.");
	}

	fread(&imgHeader, sizeof(BITMAPHEADER), 1, img);
	if(imgHeader.biBitCount != 1) {
		printf("The given file is not a binary bitmap.");
	}

    imgHeight = imgHeader.biHeight;
    imgWidth  = imgHeader.biWidth;
	printf("%d %d", imgWidth, imgHeight);
	int rowSize = (imgWidth + 31) / 32 * 4;
	int imgDataSize = rowSize * imgHeight;
	uint8_t imgDataRaw[imgDataSize];
	uint8_t *imgData = (uint8_t*)malloc(imgDataSize * 8);


	fread(imgDataRaw, imgDataSize, 1, img);

	/* Convert image data to byte */
	int imgDataWidth = rowSize * 8;
	for(int i = 0; i < imgHeight; ++i) {
		for(int j = 0; j < imgDataWidth; ++j) {
			imgData[i*imgDataWidth + j] = ((imgDataRaw[i*rowSize + j/8] >> (7-j % 8)) & 1);
		}
	}
	
	//for(int i = 0; i < imgHeight; ++i) {
	//	printf("\n");
	//	for(int j = 0; j < imgDataWidth; ++j) {
	//		printf("%d", imgData[i*imgDataWidth + j]);
	//	}
	//}
	fclose(img);
	return imgData;
}

void writeImg(uint8_t *imgData) {
	FILE* img = fopen("output.bmp", "wb");
	
	int rowSize = (imgWidth + 31) / 32 * 4;
	int imgDataSize = rowSize * imgHeight;
	uint8_t *imgDataRaw = (uint8_t*)calloc(imgDataSize, 1);
	//memset(imgDataRaw, 0, imgDataSize);
	int imgDataWidth = rowSize * 8;

	/* Convert image data to bit */
	for(int i = 0; i < imgHeight; ++i) {
		for(int j = 0; j < imgDataWidth; ++j) {
			imgDataRaw[i*rowSize + j/8] |= (imgData[i*imgDataWidth + j] * 128) >> (j%8);
		}
	}

	fwrite(&imgHeader, sizeof(BITMAPHEADER), 1, img);
	fwrite(imgDataRaw, sizeof(uint8_t), imgDataSize, img);
	fclose(img);
	free(imgDataRaw);
	return;
}

uint8_t* readMessage(char *message) {
	mSize = strlen(message) * 8;
	uint8_t *bMessage = (uint8_t*)calloc(mSize, 1);
	//memset(bMessage, 0, mSize);

	for(int i = 0; i < mSize; ++i) {
		bMessage[i] = (message[i/8] >> (7-i % 8)) & 1;
	}
	return bMessage;
}

int sum(uint8_t *block) {
	int sum = 0;
	for(int i = 0; i < bHeight; ++i) {
		for(int j = 0; j < bWidth; ++j) {
			sum += block[i*bWidth + j] & 1;
		}
	}
	return sum;
}

uint8_t* extract(uint8_t *imgData, int curBlock) {
	uint8_t *block = (uint8_t*)malloc(bHeight*bWidth);
	//memset(block, 0, bHeight*bWidth);
	
	for(int i = 0; i < bHeight; ++i) {
		for(int j = 0; j < bWidth; ++j) {
			int pNBlockHor = imgDataWidth / bWidth; //Possible number of blocks horizontally
			int verPos = bHeight * (curBlock / pNBlockHor) + i; //Row pos
			int horPos = bWidth * (curBlock % pNBlockHor) + j; //Column pos
			block[i*bWidth + j] = imgData[verPos*imgDataWidth + horPos];
		}
	}
	return block;
}

uint8_t* bAndK(uint8_t *b, uint8_t *k) {
	uint8_t *bAndK = (uint8_t*)malloc(bWidth*bHeight);

	for(int i = 0; i < bHeight; ++i) {
		for(int j = 0; j < bWidth; ++j) {
			int curPos = i*bWidth + j;
			bAndK[curPos] = b[curPos] & k[curPos];
		}
	}
	return bAndK;
}

void complement(uint8_t *imgData, uint8_t *key, int curBlock) {
	uint8_t *block = extract(imgData, curBlock);
	int sumBAndK = sum(bAndK(block, key));
	srand(time(0));
	int i, j;

	if(sumBAndK == 1) {
		do {
			i = rand() % bHeight;
			j = rand() % bWidth;
		} while(block[i*bWidth + j] != 0 || key[i*bWidth + j] != 1);
	}
	else if(sumBAndK == sum(key) - 1) {
		do {
			i = rand() % bHeight;
			j = rand() % bWidth;
		} while(block[i*bWidth + j] != 1 || key[i*bWidth + j] != 1);
	}
	else {
		do {
			i = rand() % bHeight;
			j = rand() % bWidth;
		} while(key[i*bWidth + j] != 1);
	}
	int pNBlockHor = imgDataWidth / bWidth; //Possible number of blocks horizontally
	int verPos = bHeight * (curBlock / pNBlockHor) + i; //Row pos
	int horPos = bWidth * (curBlock % pNBlockHor) + j; //Column pos
	imgData[verPos*imgDataWidth + horPos] ^= 1;
	return;
}

void encode(uint8_t *imgData, uint8_t *key, uint8_t *message) {
	Embed message size at beginning of the message
	uint8_t message[mSize + 8];
	for(int i = 0; i < 8; ++i) {
		message[i] = (mSize >> (7-i % 8)) & 1;
	}
	memcpy(message+8, bMessage, mSize);

	int pNBlock = imgHeight/bHeight * imgDataWidth/bWidth; /*Possible number of blocks image can contain*/
	for(int curBit = 0, curBlock = -1;  curBit < mSize; ++curBit) {
		int sumBAndK = 0;
		uint8_t *block;
		do {
			++curBlock;
			if(curBlock >= pNBlock) {
				printf("The message is too long.");
				return;
			}
			block = extract(imgData, curBlock);
			sumBAndK = sum(bAndK(block, key));
		} while(sumBAndK <= 0 || sumBAndK >= sum(key));

		if(sumBAndK % 2 == message[curBit]) continue;
		else complement(imgData, key, curBlock);
	}
	writeImg(imgData);
	printf("Concealing message is succeeded.");
	return;
}

char* decode(uint8_t *imgData, uint8_t *key) {
	int pNBlock = imgDataWidth/bWidth * imgHeight/bHeight;
	uint8_t *block;
	int curBlock = -1;
	int sumBAndK;

	uint8_t mSize = 0;
	for(int i = 0; i < 8; ++i) {

		do {
			++curBlock;
			block = extract(imgData, curBlock);
			sumBAndK = sum(bAndK(block, key));
		} while(sumBAndK <= 0 || sumBAndK >= sum(key));

		mSize |= ((sumBAndK%2) * 128) >> (i%8);
	}

	if(mSize*8 > pNBlock) return "Wrong image.";

	char *message = (char*)calloc(mSize, 1);
	for(int curBit = 0; curBit < mSize*8; ++curBit) {
		do {
			++curBlock;
			block = extract(imgData, curBlock);
			sumBAndK = sum(bAndK(block, key));
		} while(sumBAndK <= 0 || sumBAndK >= sum(key));
		message[curBit/8] |= ((sumBAndK%2) * 128) >> (curBit%8);
	}
	return message;
}



int main(int argc, uint8_t **argv) {
	uint8_t key[9] = {1, 0, 0,
					  0, 1, 0,
					  0, 1, 1};
	bWidth = bHeight = 3;

	uint8_t *imgData = readImg("lena.bmp");
	uint8_t *binMes = readMessage("two plus two is four.");
	encode(imgData, key, binMes);
	decode(imgData, key);

	


	//imgDataWidth = 32;
	//imgHeight = 3;
	//uint8_t *imgData = (uint8_t*)calloc(96, 1);
	//imgData[0] = 1;
	//imgData[1] = 1;
	//imgData[33] = 1;
	//imgData[6] = 1;

	//mSize = 1;
	//uint8_t binMes[] = {1};

	//uint8_t b[9] = {1, 0, 0, 0, 1, 0, 0, 0, 1};
	//uint8_t k[9] = {1, 0, 0, 1, 0, 0, 0, 0, 1};


	//uint8_t *and = extract(imgData, 0);
	//for(int i = 0; i < 96; ++i) {
	//	if(i%32== 0) printf("\n");
	//	printf("%d", imgData[i]);
	//}
	//for(int i = 0; i < 9; ++i) {
	//	if(i%3 == 0) printf("\n");
	//	printf("%d", and[i]);
	//}
	//printf("\n%d\n", sum(bAndK(and, key)));
	//encode(imgData, key, binMes);
	//for(int i = 0; i < 96; ++i) {
	//	if(i%32== 0) printf("\n");
	//	printf("%d", imgData[i]);
	//}

	//char *mes = decode(imgData, key);
	//printf("\n%d", *(uint8_t*)mes);


	



	return 0;
}

